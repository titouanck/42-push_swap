Algorithm name: Dewey

PAS ENCORE IMPLANTÉ

var_I = 0;
Tant que var_I est inférieur a <nombre d'éléments>:
	var_J = 0;
	Tant que var_J est inférieur a <nombre d'éléments>:
		(Situation: On pars du haut de la pile a - var_J éléments)
		var_DANS-LE-BON-ORDRE = -var_I;
		var_LAST-NUMBER = <Nombre plus petit que le minimum possible>;
		while j est inférieur a <nombre d'éléments>:
			if pile_a[var_J] > var_LAST-NUMBER:
				var_DANS-LE-BON-ORDRE += 1;
				var_LAST-NUMBER = pile_a[var_J];
		j++;
	Si est DANS-LE-BON-ORDRE est supérieur a celui des autres possibilitées deja effectuees:
		Garder en memoire ce point de départ.
	>> ROTATE_A <<
	i++;
Se placer sur le bon point de part (Rotate a / Reverse_rotate a);
Créer un tableau de tous les nombres intrus;
Tant que la pile a n'est pas triée:
	Trouver l'élément le plus proche du haut de la pile a parmis \
	/ {plus petit, deuxième plus petit, plus grand, deuxième plus grand}.
	Mettre cet élément en haut de la pile de la maniere la plus efficace possible {RA / RRA / SA};
	Si cet élément était le premier plus petit:
		Ne rien faire.
	Sinon si cet élément était le deuxième plus petit:
		On met l'élément le plus petit en haut de la pile.
		Si la pile a est triée:
			>> PUSH_A <<
			>> SWAP_A <<
		Sinon:
			>> PUSH_B <<
			>> SWAP_B <<
	Sinon si cet élément était le plus grand:
		>> ROTATE_B <<
	Sinon si cet élément était le deuxième plus grand:
		On met l'élément le plus grand en haut de la pile.
		>> PUSH_B <<
		>> ROTATE_B <<
		>> ROTATE_B <<
Boucle tant que la pile b n'est pas vide :
	Si a n'est pas vide \
	& que l'élément en haut de b est plus grand que celui en haut de a:
		BREAK ;
	Sinon
		>> PUSH_A <<
Boucle tant que la pile b n'est pas vide:
	>> REV_ROTATE_B <<
	>> PUSH_A <<
	>> ROTATE_A <<
